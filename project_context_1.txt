====================================================================
==== FILE: backend/package.json ====
====================================================================

{
  "name": "earth-pulse-irrigate-backend",
  "version": "1.0.0",
  "description": "Backend for the smart irrigation system",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon -r dotenv/config server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Joshua, Mallikarjun, Sanket",
  "license": "ISC",
  "dependencies": {
    "axios": "^1.9.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "mongoose": "^8.5.1",
    "node-cron": "^3.0.3"
  },
  "devDependencies": {
    "nodemon": "^3.1.4"
  }
}


====================================================================
==== FILE: backend/.env ====
====================================================================

# MongoDB Connection String
MONGODB_URI=mongodb://127.0.0.1:27017/earth_pulse_irrigate

# Server Port
PORT=5001

# Node Environment
NODE_ENV=development

OPENWEATHER_API_KEY=4b1d858ffea7d146a1089dcea72daeb1

====================================================================
==== FILE: backend/server.js ====
====================================================================

const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const dotenv = require('dotenv');
const cron = require('node-cron');

dotenv.config();

// Import routes
const cropRoutes = require('./routes/crops');
const sensorRoutes = require('./routes/sensors');
const weatherRoutes = require('./routes/weather');
const irrigationRoutes = require('./routes/irrigation');
const aiRoutes = require('./routes/ai');

// Import services
const { updateIrrigationRecommendations } = require('./services/irrigationService');
const { generateSensorData } = require('./services/sensorService');

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// MongoDB connection
// MongoDB connection
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/irrigation_system')
.then(() => console.log('Connected to MongoDB'))
.catch((error) => console.error('MongoDB connection error:', error));

// Routes
app.use('/api/crops', cropRoutes);
app.use('/api/sensors', sensorRoutes);
app.use('/api/weather', weatherRoutes);
app.use('/api/irrigation', irrigationRoutes);
app.use('/api/ai', aiRoutes);

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    message: 'Irrigation System Backend is running'
  });
});

// Scheduled tasks
// Update irrigation recommendations every hour
cron.schedule('0 * * * *', async () => {
  console.log('Running scheduled irrigation recommendations update...');
  try {
    await updateIrrigationRecommendations();
    console.log('Irrigation recommendations updated successfully');
  } catch (error) {
    console.error('Error updating irrigation recommendations:', error);
  }
});

// Generate sensor data every 5 minutes (for demo purposes)
cron.schedule('*/5 * * * *', async () => {
  try {
    await generateSensorData();
    console.log('Sensor data generated successfully');
  } catch (error) {
    console.error('Error generating sensor data:', error);
  }
});

// Error handling middleware
// --- NEW ROBUST ERROR HANDLING MIDDLEWARE ---
app.use((error, req, res, next) => {
  // Log the full error stack for debugging
  console.error("--- GLOBAL ERROR HANDLER ---");
  console.error("Error Status:", error.status);
  console.error("Error Message:", error.message);
  console.error("Request Body:", req.body); // See what body caused the error
  console.error(error.stack); // Full stack trace
  console.error("--------------------------");

  // If the error is from the body-parser (malformed JSON)
  if (error instanceof SyntaxError && error.status === 400 && 'body' in error) {
    return res.status(400).json({
      success: false,
      message: 'Malformed JSON in request body.',
      error: error.message
    });
  }

  // General error response
  res.status(error.status || 500).json({
    success: false,
    message: error.message || 'Internal Server Error',
    error: error.stack // Send stack in dev mode for easier debugging
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    error: {
      message: 'Route not found',
      status: 404
    }
  });
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
});

====================================================================
==== FILE: backend/models/Crop.js ====
====================================================================

const mongoose = require('mongoose');

const cropSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  stage: {
    type: String,
    enum: ['Seedling', 'Growing', 'Mature', 'Harvesting'],
    required: true
  },
  waterNeeds: {
    type: String,
    enum: ['Low', 'Medium', 'Medium-High', 'High'],
    required: true
  },
  plantedDate: {
    type: Date,
    required: true
  },
  nextWatering: {
    type: Date,
    required: true
  },
  lastWatered: {
    type: Date,
    default: null
  },
  waterRequirement: {
    // Water requirement in liters per day
    dailyAmount: {
      type: Number,
      required: true
    },
    // Frequency in days
    frequency: {
      type: Number,
      required: true
    }
  },
  location: {
    section: {
      type: String,
      required: true
    },
    coordinates: {
      latitude: Number,
      longitude: Number
    }
  },
  soilType: {
    type: String,
    enum: ['Sandy', 'Clay', 'Loamy', 'Silty'],
    default: 'Loamy'
  },
  cropType: {
    type: String,
    required: true
  },
  variety: {
    type: String,
    default: ''
  },
  expectedHarvestDate: {
    type: Date
  },
  growthStageHistory: [{
    stage: String,
    date: Date,
    notes: String
  }],
  irrigationHistory: [{
    date: Date,
    amount: Number, // in liters
    method: {
      type: String,
      enum: ['Manual', 'Automatic', 'Scheduled'],
      default: 'Manual'
    },
    duration: Number, // in minutes
    notes: String
  }],
  healthStatus: {
    type: String,
    enum: ['Excellent', 'Good', 'Fair', 'Poor', 'Critical'],
    default: 'Good'
  },
  notes: {
    type: String,
    default: ''
  },
  isActive: {
    type: Boolean,
    default: true
  },
  alerts: [{
    type: {
      type: String,
      enum: ['WaterDeficit', 'Overwatering', 'StageChange', 'Maintenance', 'Harvest']
    },
    message: String,
    severity: {
      type: String,
      enum: ['Low', 'Medium', 'High', 'Critical'],
      default: 'Medium'
    },
    isRead: {
      type: Boolean,
      default: false
    },
    createdAt: {
      type: Date,
      default: Date.now
    }
  }],

  aiSchedule: {
    schedule: [Number], // Array of 14 0s and 1s
    quantity: [Number], // Array of 14 numbers for water quantity
    generatedAt: Date,
    source: {
        type: String,
        default: 'ViT-Model'
    }
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual for days since planted
cropSchema.virtual('daysSincePlanted').get(function() {
  return Math.floor((Date.now() - this.plantedDate.getTime()) / (1000 * 60 * 60 * 24));
});

// Virtual for days until next watering
cropSchema.virtual('daysUntilWatering').get(function() {
  return Math.ceil((this.nextWatering.getTime() - Date.now()) / (1000 * 60 * 60 * 24));
});

// Virtual for irrigation status
cropSchema.virtual('irrigationStatus').get(function() {
  const now = new Date();
  const timeDiff = this.nextWatering.getTime() - now.getTime();
  const hoursDiff = timeDiff / (1000 * 60 * 60);
  
  if (hoursDiff < 0) return 'Overdue';
  if (hoursDiff < 24) return 'Due Soon';
  if (hoursDiff < 48) return 'Upcoming';
  return 'Scheduled';
});

// Methods
cropSchema.methods.waterCrop = function(amount, method = 'Manual', duration = 0, notes = '') {
  this.lastWatered = new Date();
  this.irrigationHistory.push({
    date: new Date(),
    amount,
    method,
    duration,
    notes
  });
  
  // Calculate next watering date based on crop requirements
  this.calculateNextWatering();
  
  return this.save();
};

cropSchema.methods.calculateNextWatering = function() {
  const baseFrequency = this.waterRequirement.frequency;
  let adjustedFrequency = baseFrequency;
  
  // Adjust frequency based on crop stage
  switch(this.stage) {
    case 'Seedling':
      adjustedFrequency = Math.max(1, baseFrequency - 1); // More frequent watering
      break;
    case 'Growing':
      adjustedFrequency = baseFrequency;
      break;
    case 'Mature':
      adjustedFrequency = baseFrequency + 1; // Less frequent watering
      break;
    case 'Harvesting':
      adjustedFrequency = baseFrequency + 1;
      break;
  }
  
  const nextWateringDate = new Date();
  nextWateringDate.setDate(nextWateringDate.getDate() + adjustedFrequency);
  this.nextWatering = nextWateringDate;
};

cropSchema.methods.updateStage = function(newStage, notes = '') {
  const oldStage = this.stage;
  this.stage = newStage;
  
  this.growthStageHistory.push({
    stage: newStage,
    date: new Date(),
    notes: notes || `Stage changed from ${oldStage} to ${newStage}`
  });
  
  // Recalculate watering schedule for new stage
  this.calculateNextWatering();
  
  return this.save();
};

// Static methods
cropSchema.statics.getCropsNeedingWater = function(daysAhead = 1) {
  const targetDate = new Date();
  targetDate.setDate(targetDate.getDate() + daysAhead);
  
  return this.find({
    nextWatering: { $lte: targetDate },
    isActive: true
  });
};

cropSchema.statics.getCropsByStage = function(stage) {
  return this.find({ stage, isActive: true });
};

// Indexes for better performance
cropSchema.index({ nextWatering: 1, isActive: 1 });
cropSchema.index({ stage: 1, isActive: 1 });
cropSchema.index({ plantedDate: 1 });
cropSchema.index({ 'location.section': 1 });

module.exports = mongoose.model('Crop', cropSchema);

====================================================================
==== FILE: backend/models/Irrigation.js ====
====================================================================

const mongoose = require('mongoose');

// Irrigation Recommendation Schema
const irrigationRecommendationSchema = new mongoose.Schema({
  cropId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Crop',
    required: true
  },
  recommendation: {
    action: {
      type: String,
      enum: ['Water today', 'Water tomorrow', 'Water in 2 days', 'Water in 3 days', 'No watering needed'],
      required: true
    },
    priority: {
      type: String,
      enum: ['Critical', 'High', 'Medium', 'Low'],
      required: true
    },
    waterAmount: {
      type: Number, // in liters
      required: true
    },
    duration: {
      type: Number, // in minutes
      required: true
    },
    method: {
      type: String,
      enum: ['Drip', 'Sprinkler', 'Manual', 'Flood'],
      default: 'Drip'
    }
  },
  factors: {
    soilMoisture: Number,
    weatherForecast: String,
    cropStage: String,
    lastWatered: Date,
    temperature: Number,
    humidity: Number
  },
  confidence: {
    type: Number,
    min: 0,
    max: 100,
    required: true
  },
  status: {
    type: String,
    enum: ['Pending', 'Approved', 'Rejected', 'Completed'],
    default: 'Pending'
  },
  scheduledDate: Date,
  completedDate: Date,
  notes: String,
  createdBy: {
    type: String,
    enum: ['System', 'User'],
    default: 'System'
  }
}, {
  timestamps: true
});

// Irrigation Schedule Schema
const irrigationScheduleSchema = new mongoose.Schema({
  cropId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Crop',
    required: true
  },
  scheduledDate: {
    type: Date,
    required: true
  },
  waterAmount: {
    type: Number,
    required: true
  },
  duration: {
    type: Number,
    required: true
  },
  method: {
    type: String,
    enum: ['Drip', 'Sprinkler', 'Manual', 'Flood'],
    default: 'Drip'
  },
  status: {
    type: String,
    enum: ['Scheduled', 'InProgress', 'Completed', 'Cancelled', 'Failed'],
    default: 'Scheduled'
  },
  isRecurring: {
    type: Boolean,
    default: false
  },
  recurringPattern: {
    frequency: {
      type: String,
      enum: ['Daily', 'Weekly', 'BiWeekly', 'Custom']
    },
    interval: Number, // days
    endDate: Date
  },
  executionDetails: {
    startTime: Date,
    endTime: Date,
    actualWaterAmount: Number,
    actualDuration: Number,
    success: Boolean,
    errors: [String]
  },
  autoExecute: {
    type: Boolean,
    default: false
  },
  createdBy: {
    type: String,
    default: 'System'
  },
  notes: String
}, {
  timestamps: true
});

// Irrigation System Schema
const irrigationSystemSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true
  },
  type: {
    type: String,
    enum: ['Drip', 'Sprinkler', 'Flood', 'Micro-sprinkler'],
    required: true
  },
  location: {
    section: String,
    coordinates: {
      latitude: Number,
      longitude: Number
    }
  },
  status: {
    type: String,
    enum: ['Active', 'Inactive', 'Maintenance', 'Error'],
    default: 'Active'
  },
  capacity: {
    flowRate: Number, // liters per minute
    pressure: Number, // bar
    coverage: Number  // square meters
  },
  connectedCrops: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Crop'
  }],
  maintenanceSchedule: {
    lastMaintenance: Date,
    nextMaintenance: Date,
    maintenanceInterval: Number // days
  },
  operationHistory: [{
    date: Date,
    operation: String,
    duration: Number,
    waterAmount: Number,
    status: String,
    notes: String
  }],
  settings: {
    autoMode: {
      type: Boolean,
      default: false
    },
    operatingHours: {
      start: String, // HH:MM
      end: String    // HH:MM
    },
    waterSource: String,
    filterType: String
  }
}, {
  timestamps: true
});

// Methods for IrrigationRecommendation
irrigationRecommendationSchema.methods.approve = function(notes = '') {
  this.status = 'Approved';
  this.notes = notes;
  return this.save();
};

irrigationRecommendationSchema.methods.reject = function(reason = '') {
  this.status = 'Rejected';
  this.notes = reason;
  return this.save();
};

irrigationRecommendationSchema.methods.complete = function() {
  this.status = 'Completed';
  this.completedDate = new Date();
  return this.save();
};

// Methods for IrrigationSchedule
irrigationScheduleSchema.methods.execute = async function() {
  this.status = 'InProgress';
  this.executionDetails.startTime = new Date();
  
  try {
    // Simulate irrigation execution
    // In real implementation, this would control actual irrigation hardware
    await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate execution time
    
    this.status = 'Completed';
    this.executionDetails.endTime = new Date();
    this.executionDetails.actualWaterAmount = this.waterAmount;
    this.executionDetails.actualDuration = this.duration;
    this.executionDetails.success = true;
    
    // Update crop's last watered date
    const Crop = mongoose.model('Crop');
    await Crop.findByIdAndUpdate(this.cropId, {
      lastWatered: new Date(),
      $push: {
        irrigationHistory: {
          date: new Date(),
          amount: this.waterAmount,
          method: 'Automatic',
          duration: this.duration,
          notes: 'Scheduled irrigation completed'
        }
      }
    });
    
    return this.save();
  } catch (error) {
    this.status = 'Failed';
    this.executionDetails.endTime = new Date();
    this.executionDetails.success = false;
    this.executionDetails.errors.push(error.message);
    return this.save();
  }
};

irrigationScheduleSchema.methods.cancel = function(reason = '') {
  this.status = 'Cancelled';
  this.notes = reason;
  return this.save();
};

// Static methods
irrigationRecommendationSchema.statics.getPendingRecommendations = function() {
  return this.find({ status: 'Pending' })
    .populate('cropId', 'name stage waterNeeds location')
    .sort({ 'recommendation.priority': 1, createdAt: 1 });
};

irrigationRecommendationSchema.statics.getRecommendationsByCrop = function(cropId) {
  return this.find({ cropId })
    .sort({ createdAt: -1 });
};

irrigationScheduleSchema.statics.getTodaysSchedule = function() {
  const today = new Date();
  const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
  const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1);
  
  return this.find({
    scheduledDate: { $gte: startOfDay, $lt: endOfDay },
    status: { $in: ['Scheduled', 'InProgress'] }
  }).populate('cropId', 'name location');
};

irrigationScheduleSchema.statics.getUpcomingSchedule = function(days = 7) {
  const today = new Date();
  const futureDate = new Date(today.getTime() + (days * 24 * 60 * 60 * 1000));
  
  return this.find({
    scheduledDate: { $gte: today, $lte: futureDate },
    status: 'Scheduled'
  }).populate('cropId', 'name location').sort({ scheduledDate: 1 });
};

// Indexes
irrigationRecommendationSchema.index({ cropId: 1, status: 1 });
irrigationRecommendationSchema.index({ createdAt: -1 });
irrigationRecommendationSchema.index({ scheduledDate: 1 });

irrigationScheduleSchema.index({ cropId: 1, status: 1 });
irrigationScheduleSchema.index({ scheduledDate: 1, status: 1 });
irrigationScheduleSchema.index({ createdAt: -1 });

irrigationSystemSchema.index({ status: 1 });
irrigationSystemSchema.index({ 'location.section': 1 });

const IrrigationRecommendation = mongoose.model('IrrigationRecommendation', irrigationRecommendationSchema);
const IrrigationSchedule = mongoose.model('IrrigationSchedule', irrigationScheduleSchema);
const IrrigationSystem = mongoose.model('IrrigationSystem', irrigationSystemSchema);

module.exports = {
  IrrigationRecommendation,
  IrrigationSchedule,
  IrrigationSystem
};

====================================================================
==== FILE: backend/models/Sensor.js ====
====================================================================

const mongoose = require('mongoose');

// Sensor Reading Schema
const sensorReadingSchema = new mongoose.Schema({
  sensorId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Sensor',
    required: true
  },
  readings: {
    soilMoisture: {
      type: Number,
      min: 0,
      max: 100 // Percentage
    },
    temperature: {
      type: Number,
      min: -50,
      max: 100 // Celsius
    },
    humidity: {
      type: Number,
      min: 0,
      max: 100 // Percentage
    },
    lightIntensity: {
      type: Number,
      min: 0,
      max: 100000 // Lux
    },
    pH: {
      type: Number,
      min: 0,
      max: 14
    },
    nutrients: {
      nitrogen: Number,
      phosphorus: Number,
      potassium: Number
    }
  },
  timestamp: {
    type: Date,
    default: Date.now
  },
  quality: {
    type: String,
    enum: ['Good', 'Fair', 'Poor'],
    default: 'Good'
  }
}, {
  timestamps: true
});

// Sensor Schema
const sensorSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  type: {
    type: String,
    enum: ['SoilMoisture', 'Temperature', 'Humidity', 'pH', 'Light', 'Nutrient', 'Multi'],
    required: true
  },
  location: {
    section: {
      type: String,
      required: true
    },
    coordinates: {
      latitude: Number,
      longitude: Number
    },
    depth: Number // for soil sensors
  },
  status: {
    type: String,
    enum: ['Active', 'Inactive', 'Maintenance', 'Error'],
    default: 'Active'
  },
  lastReading: {
    type: Date,
    default: null
  },
  batteryLevel: {
    type: Number,
    min: 0,
    max: 100,
    default: 100
  },
  calibrationDate: {
    type: Date,
    default: Date.now
  },
  alertThresholds: {
    soilMoisture: {
      min: { type: Number, default: 20 },
      max: { type: Number, default: 80 }
    },
    temperature: {
      min: { type: Number, default: 5 },
      max: { type: Number, default: 35 }
    },
    humidity: {
      min: { type: Number, default: 40 },
      max: { type: Number, default: 90 }
    },
    pH: {
      min: { type: Number, default: 6.0 },
      max: { type: Number, default: 7.5 }
    }
  },
  associatedCrops: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Crop'
  }],
  notes: {
    type: String,
    default: ''
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Weather Data Schema
const weatherSchema = new mongoose.Schema({
  location: {
    name: String,
    coordinates: {
      latitude: Number,
      longitude: Number
    }
  },
  current: {
    temperature: Number,
    humidity: Number,
    windSpeed: Number,
    windDirection: Number,
    pressure: Number,
    visibility: Number,
    uvIndex: Number,
    cloudCover: Number,
    condition: String,
    precipitation: Number
  },
  forecast: [{
    date: Date,
    temperature: {
      min: Number,
      max: Number
    },
    humidity: Number,
    precipitation: {
      probability: Number,
      amount: Number
    },
    windSpeed: Number,
    condition: String
  }],
  timestamp: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

// Virtual for sensor health status
sensorSchema.virtual('healthStatus').get(function() {
  if (this.status === 'Error') return 'Critical';
  if (this.batteryLevel < 20) return 'Low Battery';
  if (this.lastReading && (Date.now() - this.lastReading.getTime()) > 24 * 60 * 60 * 1000) {
    return 'No Recent Data';
  }
  return 'Good';
});

// Methods
sensorSchema.methods.addReading = function(readings) {
  this.lastReading = new Date();
  
  // Create new sensor reading
  const SensorReading = mongoose.model('SensorReading');
  const newReading = new SensorReading({
    sensorId: this._id,
    readings: readings
  });
  
  return newReading.save();
};

sensorSchema.methods.getLatestReading = function() {
  const SensorReading = mongoose.model('SensorReading');
  return SensorReading.findOne({ sensorId: this._id }).sort({ timestamp: -1 });
};

sensorSchema.methods.getReadingsInRange = function(startDate, endDate) {
  const SensorReading = mongoose.model('SensorReading');
  return SensorReading.find({
    sensorId: this._id,
    timestamp: { $gte: startDate, $lte: endDate }
  }).sort({ timestamp: -1 });
};

sensorSchema.methods.checkAlerts = async function() {
  const latestReading = await this.getLatestReading();
  if (!latestReading) return [];
  
  const alerts = [];
  const readings = latestReading.readings;
  const thresholds = this.alertThresholds;
  
  // Check soil moisture
  if (readings.soilMoisture !== undefined) {
    if (readings.soilMoisture < thresholds.soilMoisture.min) {
      alerts.push({
        type: 'SoilMoisture',
        message: `Low soil moisture: ${readings.soilMoisture}%`,
        severity: 'High',
        value: readings.soilMoisture
      });
    } else if (readings.soilMoisture > thresholds.soilMoisture.max) {
      alerts.push({
        type: 'SoilMoisture',
        message: `High soil moisture: ${readings.soilMoisture}%`,
        severity: 'Medium',
        value: readings.soilMoisture
      });
    }
  }
  
  // Check temperature
  if (readings.temperature !== undefined) {
    if (readings.temperature < thresholds.temperature.min || 
        readings.temperature > thresholds.temperature.max) {
      alerts.push({
        type: 'Temperature',
        message: `Temperature out of range: ${readings.temperature}°C`,
        severity: 'Medium',
        value: readings.temperature
      });
    }
  }
  
  // Check pH
  if (readings.pH !== undefined) {
    if (readings.pH < thresholds.pH.min || readings.pH > thresholds.pH.max) {
      alerts.push({
        type: 'pH',
        message: `pH out of range: ${readings.pH}`,
        severity: 'Medium',
        value: readings.pH
      });
    }
  }
  
  return alerts;
};

// Static methods
sensorSchema.statics.getActiveSensors = function() {
  return this.find({ status: 'Active' });
};

sensorSchema.statics.getSensorsByLocation = function(section) {
  return this.find({ 'location.section': section, status: 'Active' });
};

// Indexes
sensorSchema.index({ 'location.section': 1, status: 1 });
sensorSchema.index({ type: 1, status: 1 });
sensorReadingSchema.index({ sensorId: 1, timestamp: -1 });
sensorReadingSchema.index({ timestamp: -1 });
weatherSchema.index({ timestamp: -1 });

const Sensor = mongoose.model('Sensor', sensorSchema);
const SensorReading = mongoose.model('SensorReading', sensorReadingSchema);
const Weather = mongoose.model('Weather', weatherSchema);

module.exports = { Sensor, SensorReading, Weather };

====================================================================
==== FILE: backend/routes/crops.js ====
====================================================================

const express = require('express');
const router = express.Router();
const Crop = require('../models/Crop');
const { IrrigationRecommendation } = require('../models/Irrigation');
const { generateIrrigationRecommendation } = require('../services/irrigationService');

// GET /api/crops - Get all crops
router.get('/', async (req, res) => {
  try {
    const { stage, waterNeeds, section, sortBy = 'createdAt', sortOrder = 'desc' } = req.query;
    
    let query = { isActive: true };
    
    // Apply filters
    if (stage) query.stage = stage;
    if (waterNeeds) query.waterNeeds = waterNeeds;
    if (section) query['location.section'] = section;
    
    const sortOptions = {};
    sortOptions[sortBy] = sortOrder === 'asc' ? 1 : -1;
    
    const crops = await Crop.find(query).sort(sortOptions);
    
    res.json({
      success: true,
      count: crops.length,
      data: crops
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching crops',
      error: error.message
    });
  }
});

// GET /api/crops/:id - Get single crop
router.get('/:id', async (req, res) => {
  try {
    const crop = await Crop.findById(req.params.id);
    
    if (!crop) {
      return res.status(404).json({
        success: false,
        message: 'Crop not found'
      });
    }
    
    res.json({
      success: true,
      data: crop
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching crop',
      error: error.message
    });
  }
});

// POST /api/crops - Create new crop
router.post('/', async (req, res) => {
  try {
    const cropData = req.body;
    
    // Set water requirements based on crop type and water needs
    const waterRequirements = {
      'Low': { dailyAmount: 0.5, frequency: 5 },
      'Medium': { dailyAmount: 1.5, frequency: 3 },
      'Medium-High': { dailyAmount: 2.5, frequency: 2 },
      'High': { dailyAmount: 4, frequency: 1 }
    };
    
    cropData.waterRequirement = waterRequirements[cropData.waterNeeds] || waterRequirements['Medium'];
    
    const crop = new Crop(cropData);
    
    // Calculate initial next watering date
    crop.calculateNextWatering();
    
    await crop.save();
    
    // Generate initial irrigation recommendation
    await generateIrrigationRecommendation(crop._id);
    
    res.status(201).json({
      success: true,
      message: 'Crop created successfully',
      data: crop
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      message: 'Error creating crop',
      error: error.message
    });
  }
});

// PUT /api/crops/:id - Update crop
router.put('/:id', async (req, res) => {
  try {
    const crop = await Crop.findById(req.params.id);
    
    if (!crop) {
      return res.status(404).json({
        success: false,
        message: 'Crop not found'
      });
    }
    
    // Update crop fields
    Object.keys(req.body).forEach(key => {
      if (req.body[key] !== undefined) {
        crop[key] = req.body[key];
      }
    });
    
    // Recalculate watering if water needs changed
    if (req.body.waterNeeds) {
      const waterRequirements = {
        'Low': { dailyAmount: 0.5, frequency: 5 },
        'Medium': { dailyAmount: 1.5, frequency: 3 },
        'Medium-High': { dailyAmount: 2.5, frequency: 2 },
        'High': { dailyAmount: 4, frequency: 1 }
      };
      crop.waterRequirement = waterRequirements[req.body.waterNeeds];
      crop.calculateNextWatering();
    }
    
    await crop.save();
    
    res.json({
      success: true,
      message: 'Crop updated successfully',
      data: crop
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      message: 'Error updating crop',
      error: error.message
    });
  }
});

// DELETE /api/crops/:id - Delete crop (soft delete)
router.delete('/:id', async (req, res) => {
  try {
    const crop = await Crop.findById(req.params.id);
    
    if (!crop) {
      return res.status(404).json({
        success: false,
        message: 'Crop not found'
      });
    }
    
    crop.isActive = false;
    await crop.save();
    
    res.json({
      success: true,
      message: 'Crop deleted successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error deleting crop',
      error: error.message
    });
  }
});

// POST /api/crops/:id/water - Water a crop
router.post('/:id/water', async (req, res) => {
  try {
    const { amount, method = 'Manual', duration = 0, notes = '' } = req.body;
    
    const crop = await Crop.findById(req.params.id);
    
    if (!crop) {
      return res.status(404).json({
        success: false,
        message: 'Crop not found'
      });
    }
    
    await crop.waterCrop(amount, method, duration, notes);
    
    // Generate new irrigation recommendation after watering
    await generateIrrigationRecommendation(crop._id);
    
    res.json({
      success: true,
      message: 'Crop watered successfully',
      data: crop
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      message: 'Error watering crop',
      error: error.message
    });
  }
});

// POST /api/crops/:id/stage - Update crop stage
router.post('/:id/stage', async (req, res) => {
  try {
    const { stage, notes } = req.body;
    
    const crop = await Crop.findById(req.params.id);
    
    if (!crop) {
      return res.status(404).json({
        success: false,
        message: 'Crop not found'
      });
    }
    
    await crop.updateStage(stage, notes);
    
    // Generate new irrigation recommendation after stage change
    await generateIrrigationRecommendation(crop._id);
    
    res.json({
      success: true,
      message: 'Crop stage updated successfully',
      data: crop
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      message: 'Error updating crop stage',
      error: error.message
    });
  }
});

// GET /api/crops/:id/history - Get crop irrigation history
router.get('/:id/history', async (req, res) => {
  try {
    const { limit = 50, offset = 0 } = req.query;
    
    const crop = await Crop.findById(req.params.id);
    
    if (!crop) {
      return res.status(404).json({
        success: false,
        message: 'Crop not found'
      });
    }
    
    const history = crop.irrigationHistory
      .sort((a, b) => new Date(b.date) - new Date(a.date))
      .slice(offset, offset + parseInt(limit));
    
    res.json({
      success: true,
      data: {
        history,
        total: crop.irrigationHistory.length
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching irrigation history',
      error: error.message
    });
  }
});

// GET /api/crops/needing-water - Get crops that need watering
router.get('/status/needing-water', async (req, res) => {
  try {
    const { days = 1 } = req.query;
    
    const crops = await Crop.getCropsNeedingWater(parseInt(days));
    
    res.json({
      success: true,
      count: crops.length,
      data: crops
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching crops needing water',
      error: error.message
    });
  }
});

// GET /api/crops/by-stage/:stage - Get crops by stage
router.get('/stage/:stage', async (req, res) => {
  try {
    const crops = await Crop.getCropsByStage(req.params.stage);
    
    res.json({
      success: true,
      count: crops.length,
      data: crops
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching crops by stage',
      error: error.message
    });
  }
});

// GET /api/crops/:id/recommendations - Get irrigation recommendations for crop
router.get('/:id/recommendations', async (req, res) => {
  try {
    const recommendations = await IrrigationRecommendation.getRecommendationsByCrop(req.params.id);
    
    res.json({
      success: true,
      count: recommendations.length,
      data: recommendations
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching recommendations',
      error: error.message
    });
  }
});

module.exports = router;

====================================================================
==== FILE: backend/routes/irrigation.js ====
====================================================================

const express = require('express');
const router = express.Router();
const { IrrigationRecommendation, IrrigationSchedule, IrrigationSystem } = require('../models/Irrigation');
const Crop = require('../models/Crop');
const { generateIrrigationRecommendation, updateIrrigationRecommendations } = require('../services/irrigationService');

// GET /api/irrigation/recommendations - Get all irrigation recommendations
router.get('/recommendations', async (req, res) => {
  try {
    const { status, priority, cropId, limit = 50, offset = 0 } = req.query;
    
    let query = {};
    if (status) query.status = status;
    if (priority) query['recommendation.priority'] = priority;
    if (cropId) query.cropId = cropId;
    
    const recommendations = await IrrigationRecommendation.find(query)
      .populate('cropId', 'name stage waterNeeds location')
      .sort({ createdAt: -1 })
      .limit(parseInt(limit))
      .skip(parseInt(offset));
    
    const total = await IrrigationRecommendation.countDocuments(query);
    
    res.json({
      success: true,
      count: recommendations.length,
      total,
      data: recommendations
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching irrigation recommendations',
      error: error.message
    });
  }
});

// GET /api/irrigation/recommendations/pending - Get pending recommendations
router.get('/recommendations/pending', async (req, res) => {
  try {
    const recommendations = await IrrigationRecommendation.getPendingRecommendations();
    
    res.json({
      success: true,
      count: recommendations.length,
      data: recommendations
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching pending recommendations',
      error: error.message
    });
  }
});

// POST /api/irrigation/recommendations/:id/approve - Approve recommendation
router.post('/recommendations/:id/approve', async (req, res) => {
  try {
    const { notes = '' } = req.body;
    
    const recommendation = await IrrigationRecommendation.findById(req.params.id);
    
    if (!recommendation) {
      return res.status(404).json({
        success: false,
        message: 'Recommendation not found'
      });
    }
    
    await recommendation.approve(notes);
    
    // Create irrigation schedule if approved
    const schedule = new IrrigationSchedule({
      cropId: recommendation.cropId,
      scheduledDate: recommendation.scheduledDate || new Date(),
      waterAmount: recommendation.recommendation.waterAmount,
      duration: recommendation.recommendation.duration,
      method: recommendation.recommendation.method,
      autoExecute: true
    });
    
    await schedule.save();
    
    res.json({
      success: true,
      message: 'Recommendation approved and scheduled',
      data: {
        recommendation,
        schedule
      }
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      message: 'Error approving recommendation',
      error: error.message
    });
  }
});

// POST /api/irrigation/recommendations/:id/reject - Reject recommendation
router.post('/recommendations/:id/reject', async (req, res) => {
  try {
    const { reason = '' } = req.body;
    
    const recommendation = await IrrigationRecommendation.findById(req.params.id);
    
    if (!recommendation) {
      return res.status(404).json({
        success: false,
        message: 'Recommendation not found'
      });
    }
    
    await recommendation.reject(reason);
    
    res.json({
      success: true,
      message: 'Recommendation rejected',
      data: recommendation
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      message: 'Error rejecting recommendation',
      error: error.message
    });
  }
});

// POST /api/irrigation/recommendations/refresh - Refresh all recommendations
router.post('/recommendations/refresh', async (req, res) => {
  try {
    await updateIrrigationRecommendations();
    
    const recommendations = await IrrigationRecommendation.getPendingRecommendations();
    
    res.json({
      success: true,
      message: 'Recommendations refreshed successfully',
      count: recommendations.length,
      data: recommendations
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error refreshing recommendations',
      error: error.message
    });
  }
});

// GET /api/irrigation/schedule - Get irrigation schedules
router.get('/schedule', async (req, res) => {
  try {
    const { status, date, cropId, limit = 50, offset = 0 } = req.query;
    
    let query = {};
    if (status) query.status = status;
    if (cropId) query.cropId = cropId;
    if (date) {
      const targetDate = new Date(date);
      const startOfDay = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());
      const endOfDay = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate() + 1);
      query.scheduledDate = { $gte: startOfDay, $lt: endOfDay };
    }
    
    const schedules = await IrrigationSchedule.find(query)
      .populate('cropId', 'name location')
      .sort({ scheduledDate: 1 })
      .limit(parseInt(limit))
      .skip(parseInt(offset));
    
    const total = await IrrigationSchedule.countDocuments(query);
    
    res.json({
      success: true,
      count: schedules.length,
      total,
      data: schedules
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching irrigation schedules',
      error: error.message
    });
  }
});

// GET /api/irrigation/schedule/today - Get today's irrigation schedule
router.get('/schedule/today', async (req, res) => {
  try {
    const schedules = await IrrigationSchedule.getTodaysSchedule();
    
    res.json({
      success: true,
      count: schedules.length,
      data: schedules
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching today\'s schedule',
      error: error.message
    });
  }
});

// GET /api/irrigation/schedule/upcoming - Get upcoming irrigation schedule
router.get('/schedule/upcoming', async (req, res) => {
  try {
    const { days = 7 } = req.query;
    
    const schedules = await IrrigationSchedule.getUpcomingSchedule(parseInt(days));
    
    res.json({
      success: true,
      count: schedules.length,
      data: schedules
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching upcoming schedule',
      error: error.message
    });
  }
});

// POST /api/irrigation/schedule - Create new irrigation schedule
router.post('/schedule', async (req, res) => {
  try {
    const scheduleData = req.body;
    
    const schedule = new IrrigationSchedule(scheduleData);
    await schedule.save();
    
    res.status(201).json({
      success: true,
      message: 'Irrigation schedule created successfully',
      data: schedule
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      message: 'Error creating irrigation schedule',
      error: error.message
    });
  }
});

// POST /api/irrigation/schedule/:id/execute - Execute irrigation schedule
router.post('/schedule/:id/execute', async (req, res) => {
  try {
    const schedule = await IrrigationSchedule.findById(req.params.id);
    
    if (!schedule) {
      return res.status(404).json({
        success: false,
        message: 'Schedule not found'
      });
    }
    
    if (schedule.status !== 'Scheduled') {
      return res.status(400).json({
        success: false,
        message: 'Schedule cannot be executed in current status'
      });
    }
    
    await schedule.execute();
    
    res.json({
      success: true,
      message: 'Irrigation executed successfully',
      data: schedule
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      message: 'Error executing irrigation',
      error: error.message
    });
  }
});

// POST /api/irrigation/schedule/:id/cancel - Cancel irrigation schedule
router.post('/schedule/:id/cancel', async (req, res) => {
  try {
    const { reason = '' } = req.body;
    
    const schedule = await IrrigationSchedule.findById(req.params.id);
    
    if (!schedule) {
      return res.status(404).json({
        success: false,
        message: 'Schedule not found'
      });
    }
    
    await schedule.cancel(reason);
    
    res.json({
      success: true,
      message: 'Schedule cancelled successfully',
      data: schedule
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      message: 'Error cancelling schedule',
      error: error.message
    });
  }
});

// GET /api/irrigation/systems - Get irrigation systems
router.get('/systems', async (req, res) => {
  try {
    const { status, type, section } = req.query;
    
    let query = {};
    if (status) query.status = status;
    if (type) query.type = type;
    if (section) query['location.section'] = section;
    
    const systems = await IrrigationSystem.find(query)
      .populate('connectedCrops', 'name location');
    
    res.json({
      success: true,
      count: systems.length,
      data: systems
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching irrigation systems',
      error: error.message
    });
  }
});

// POST /api/irrigation/systems - Create new irrigation system
router.post('/systems', async (req, res) => {
  try {
    const system = new IrrigationSystem(req.body);
    await system.save();
    
    res.status(201).json({
      success: true,
      message: 'Irrigation system created successfully',
      data: system
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      message: 'Error creating irrigation system',
      error: error.message
    });
  }
});

// PUT /api/irrigation/systems/:id - Update irrigation system
router.put('/systems/:id', async (req, res) => {
  try {
    const system = await IrrigationSystem.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true }
    );
    
    if (!system) {
      return res.status(404).json({
        success: false,
        message: 'Irrigation system not found'
      });
    }
    
    res.json({
      success: true,
      message: 'Irrigation system updated successfully',
      data: system
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      message: 'Error updating irrigation system',
      error: error.message
    });
  }
});

// GET /api/irrigation/dashboard - Get irrigation dashboard data
router.get('/dashboard', async (req, res) => {
  try {
    // Get pending recommendations
    const pendingRecommendations = await IrrigationRecommendation.getPendingRecommendations();
    
    // Get today's schedule
    const todaySchedule = await IrrigationSchedule.getTodaysSchedule();
    
    // Get upcoming schedule
    const upcomingSchedule = await IrrigationSchedule.getUpcomingSchedule(7);
    
    // Get crops needing water
    const cropsNeedingWater = await Crop.getCropsNeedingWater(1);
    
    // Get system status
    const activeSystems = await IrrigationSystem.find({ status: 'Active' });
    
    res.json({
      success: true,
      data: {
        pendingRecommendations: pendingRecommendations.slice(0, 5),
        todaySchedule: todaySchedule.slice(0, 10),
        upcomingSchedule: upcomingSchedule.slice(0, 10),
        cropsNeedingWater: cropsNeedingWater.slice(0, 5),
        systemsStatus: {
          active: activeSystems.length,
          total: await IrrigationSystem.countDocuments()
        },
        summary: {
          pendingCount: pendingRecommendations.length,
          todayCount: todaySchedule.length,
          upcomingCount: upcomingSchedule.length,
          urgentCount: cropsNeedingWater.length
        }
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching dashboard data',
      error: error.message
    });
  }
});

module.exports = router;

====================================================================
==== FILE: backend/routes/sensors.js ====
====================================================================

const express = require('express');
const router = express.Router();
const { Sensor, SensorReading } = require('../models/Sensor');

// GET /api/sensors - Get all sensors
router.get('/', async (req, res) => {
  try {
    const { status, type, section } = req.query;
    let query = {};
    if (status) query.status = status;
    if (type) query.type = type;
    if (section) query['location.section'] = section;

    const sensors = await Sensor.find(query);
    res.json({ success: true, count: sensors.length, data: sensors });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching sensors', error: error.message });
  }
});

// GET /api/sensors/:id - Get a single sensor
router.get('/:id', async (req, res) => {
  try {
    const sensor = await Sensor.findById(req.params.id);
    if (!sensor) {
      return res.status(404).json({ success: false, message: 'Sensor not found' });
    }
    res.json({ success: true, data: sensor });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching sensor', error: error.message });
  }
});

// POST /api/sensors - Create a new sensor
router.post('/', async (req, res) => {
  try {
    const sensor = new Sensor(req.body);
    await sensor.save();
    res.status(201).json({ success: true, message: 'Sensor created successfully', data: sensor });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error creating sensor', error: error.message });
  }
});

// PUT /api/sensors/:id - Update a sensor
router.put('/:id', async (req, res) => {
  try {
    const sensor = await Sensor.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });
    if (!sensor) {
      return res.status(404).json({ success: false, message: 'Sensor not found' });
    }
    res.json({ success: true, message: 'Sensor updated successfully', data: sensor });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error updating sensor', error: error.message });
  }
});

// GET /api/sensors/:id/readings - Get sensor readings for a specific sensor
router.get('/:id/readings', async (req, res) => {
  try {
    const { limit = 100, sort = 'desc' } = req.query;
    const sensor = await Sensor.findById(req.params.id);
    if (!sensor) {
        return res.status(404).json({ success: false, message: 'Sensor not found' });
    }

    const readings = await SensorReading.find({ sensorId: req.params.id })
        .sort({ timestamp: sort === 'asc' ? 1 : -1 })
        .limit(parseInt(limit));
        
    res.json({ success: true, count: readings.length, data: readings });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching sensor readings', error: error.message });
  }
});

const { generateSensorData } = require('../services/sensorService');

router.post('/generate-test-data', async (req, res) => {
    try {
        console.log('Manual trigger for generateSensorData received.');
        await generateSensorData();
        res.status(200).json({ 
            success: true, 
            message: 'Sensor data generation task completed successfully.' 
        });
    } catch (error) {
        console.error('Error during manual data generation trigger:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Failed to generate sensor data.',
            error: error.message
        });
    }
});

module.exports = router;

====================================================================
==== FILE: backend/routes/weather.js ====
====================================================================

const express = require('express');
const router = express.Router();
const { getWeatherData } = require('../services/weatherService');

// GET /api/weather/bangalore - Get the latest weather for Bangalore
router.get('/bangalore', async (req, res, next) => {
    try {
        const weatherData = await getWeatherData(); // Uses default Bangalore coordinates
        res.json({ success: true, data: weatherData });
    } catch (error) {
        // Pass the error to the global error handler
        next(error);
    }
});

// GET /api/weather/by-coords?lat=...&lon=... - Get weather for specific coordinates
router.get('/by-coords', async (req, res, next) => {
    try {
        const { lat, lon } = req.query;
        if (!lat || !lon) {
            return res.status(400).json({ success: false, message: 'Latitude (lat) and Longitude (lon) are required query parameters.' });
        }
        const weatherData = await getWeatherData(parseFloat(lat), parseFloat(lon));
        res.json({ success: true, data: weatherData });
    } catch (error) {
        next(error);
    }
});

module.exports = router;

====================================================================
==== FILE: backend/services/irrigationService.js ====
====================================================================

const Crop = require('../models/Crop');
const { IrrigationRecommendation } = require('../models/Irrigation');
const { Sensor, SensorReading, Weather } = require('../models/Sensor');

/**
 * Generates or updates an irrigation recommendation for a single crop.
 * @param {string} cropId - The ID of the crop to generate a recommendation for.
 */
const generateIrrigationRecommendation = async (cropId) => {
  try {
    const crop = await Crop.findById(cropId);
    if (!crop || !crop.isActive) {
      // If crop not found or inactive, do nothing.
      return null;
    }

    // --- Gather Data ---
    // 1. Get latest sensor reading near the crop
    const sensor = await Sensor.findOne({ 'location.section': crop.location.section, type: 'SoilMoisture', status: 'Active' });
    const latestReading = sensor ? await SensorReading.findOne({ sensorId: sensor._id }).sort({ timestamp: -1 }) : null;
    const soilMoisture = latestReading ? latestReading.readings.soilMoisture : 50; // Default if no sensor

    // 2. Get latest weather forecast
    const weather = await Weather.findOne().sort({ timestamp: -1 });
    const rainProbability = weather?.forecast[0]?.precipitation?.probability || 0;

    // --- Decision Logic ---
    let recommendation = {};
    let confidence = 75; // Base confidence
    const daysUntilWatering = crop.daysUntilWatering;

    if (daysUntilWatering <= 0) {
      recommendation = { action: 'Water today', priority: 'Critical' };
      confidence = 95;
    } else if (daysUntilWatering === 1) {
      recommendation = { action: 'Water tomorrow', priority: 'High' };
      confidence = 90;
    } else if (daysUntilWatering === 2) {
      recommendation = { action: 'Water in 2 days', priority: 'Medium' };
    } else {
      recommendation = { action: 'No watering needed', priority: 'Low' };
    }

    // Adjust based on soil moisture
    if (soilMoisture < 25 && recommendation.priority !== 'Critical') {
        recommendation.priority = 'High';
        recommendation.action = 'Water tomorrow';
        confidence = Math.min(100, confidence + 15);
    }
    
    // Adjust based on weather forecast (e.g., if high chance of rain, postpone)
    if (rainProbability > 60 && ['High', 'Medium'].includes(recommendation.priority)) {
        recommendation.action = 'No watering needed';
        recommendation.priority = 'Low';
        confidence = 85;
    }

    // Finalize recommendation details
    recommendation.waterAmount = crop.waterRequirement.dailyAmount;
    recommendation.duration = crop.waterRequirement.dailyAmount * 5; // Example: 5 mins per liter
    recommendation.method = 'Drip';

    const recommendationData = {
      cropId: crop._id,
      recommendation,
      factors: {
        soilMoisture,
        weatherForecast: `Rain probability: ${rainProbability}%`,
        cropStage: crop.stage,
        lastWatered: crop.lastWatered,
      },
      confidence: Math.round(confidence),
      scheduledDate: crop.nextWatering,
      status: 'Pending'
    };
    
    // Use findOneAndUpdate with upsert to create or update the pending recommendation for this crop
    const result = await IrrigationRecommendation.findOneAndUpdate(
        { cropId: crop._id, status: 'Pending' }, // Find existing pending recommendation
        recommendationData, // The new data
        { new: true, upsert: true, runValidators: true } // Options: return new doc, create if not found
    );
    
    console.log(`Generated recommendation for crop ${crop.name}: ${result.recommendation.action}`);
    return result;

  } catch (error) {
    console.error(`Error generating recommendation for crop ${cropId}:`, error);
  }
};

/**
 * Iterates through all active crops and updates their irrigation recommendations.
 * This is used by a cron job.
 */
const updateIrrigationRecommendations = async () => {
  try {
    const activeCrops = await Crop.find({ isActive: true });
    console.log(`Updating recommendations for ${activeCrops.length} active crops.`);

    for (const crop of activeCrops) {
      await generateIrrigationRecommendation(crop._id);
    }
    
    console.log('Finished updating all irrigation recommendations.');
  } catch (error) {
    console.error('Error in updateIrrigationRecommendations service:', error);
  }
};

module.exports = {
  generateIrrigationRecommendation,
  updateIrrigationRecommendations
};

====================================================================
==== FILE: backend/services/sensorService.js ====
====================================================================

const { Sensor, SensorReading } = require('../models/Sensor');

/**
 * Generates a random number within a given range.
 * @param {number} min - The minimum value.
 * @param {number} max - The maximum value.
 * @returns {number} A random number.
 */
const getRandom = (min, max, decimals = 2) => {
  return parseFloat((Math.random() * (max - min) + min).toFixed(decimals));
};

/**
 * Generates simulated sensor data for all active sensors.
 * This is used by a cron job for demo purposes.
 */
const generateSensorData = async () => {
  console.log('Generating new sensor data...');
  try {
    const activeSensors = await Sensor.find({ status: 'Active' });

    if (activeSensors.length === 0) {
      console.log('No active sensors found to generate data for.');
      return;
    }

    const readingPromises = activeSensors.map(sensor => {
      const readings = {
        soilMoisture: getRandom(15, 85),
        temperature: getRandom(18, 32),
        humidity: getRandom(40, 90),
        pH: getRandom(6.0, 7.5)
      };
      
      const newReading = new SensorReading({
        sensorId: sensor._id,
        readings: readings
      });

      // Update the sensor's last reading time
      sensor.lastReading = new Date();
      sensor.batteryLevel = Math.max(0, sensor.batteryLevel - getRandom(0.01, 0.05)); // Simulate battery drain

      return Promise.all([newReading.save(), sensor.save()]);
    });

    await Promise.all(readingPromises);
    console.log(`Generated and saved new readings for ${activeSensors.length} sensors.`);
  } catch (error) {
    console.error('Error in generateSensorData service:', error);
  }
};

module.exports = {
  generateSensorData
};

====================================================================
==== FILE: package.json ====
====================================================================

{
  "name": "vite_react_shadcn_ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.0",
    "@radix-ui/react-accordion": "^1.2.0",
    "@radix-ui/react-alert-dialog": "^1.1.1",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.0",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-collapsible": "^1.1.0",
    "@radix-ui/react-context-menu": "^2.2.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-hover-card": "^1.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.1",
    "@radix-ui/react-navigation-menu": "^1.2.0",
    "@radix-ui/react-popover": "^1.1.1",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.0",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.1",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@tanstack/react-query": "^5.56.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "date-fns": "^3.6.0",
    "embla-carousel-react": "^8.3.0",
    "input-otp": "^1.2.4",
    "lucide-react": "^0.462.0",
    "next-themes": "^0.3.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.53.0",
    "react-resizable-panels": "^2.1.3",
    "react-router-dom": "^6.26.2",
    "recharts": "^2.12.7",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@tailwindcss/typography": "^0.5.15",
    "@types/node": "^22.5.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.9.0",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "globals": "^15.9.0",
    "lovable-tagger": "^1.1.7",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.11",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.0.1",
    "vite": "^5.4.1"
  }
}


====================================================================
==== FILE: vite.config.ts ====
====================================================================

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";
import { componentTagger } from "lovable-tagger";

// https://vitejs.dev/config/

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:5001', // Your backend server
        changeOrigin: true,
        secure: false,      
      }
    }
  }
})

/*
export default defineConfig(({ mode }) => ({
  server: {
    host: "::",
    port: 8080,
  },
  plugins: [
    react(),
    mode === 'development' &&
    componentTagger(),
  ].filter(Boolean),
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
}));
*/

====================================================================
==== FILE: tailwind.config.ts ====
====================================================================


import type { Config } from "tailwindcss";

export default {
	darkMode: ["class"],
	content: [
		"./pages/**/*.{ts,tsx}",
		"./components/**/*.{ts,tsx}",
		"./app/**/*.{ts,tsx}",
		"./src/**/*.{ts,tsx}",
	],
	prefix: "",
	theme: {
		container: {
			center: true,
			padding: '2rem',
			screens: {
				'2xl': '1400px'
			}
		},
		extend: {
			colors: {
				border: 'hsl(var(--border))',
				input: 'hsl(var(--input))',
				ring: 'hsl(var(--ring))',
				background: 'hsl(var(--background))',
				foreground: 'hsl(var(--foreground))',
				primary: {
					DEFAULT: 'hsl(var(--primary))',
					foreground: 'hsl(var(--primary-foreground))'
				},
				secondary: {
					DEFAULT: 'hsl(var(--secondary))',
					foreground: 'hsl(var(--secondary-foreground))'
				},
				destructive: {
					DEFAULT: 'hsl(var(--destructive))',
					foreground: 'hsl(var(--destructive-foreground))'
				},
				muted: {
					DEFAULT: 'hsl(var(--muted))',
					foreground: 'hsl(var(--muted-foreground))'
				},
				accent: {
					DEFAULT: 'hsl(var(--accent))',
					foreground: 'hsl(var(--accent-foreground))'
				},
				popover: {
					DEFAULT: 'hsl(var(--popover))',
					foreground: 'hsl(var(--popover-foreground))'
				},
				card: {
					DEFAULT: 'hsl(var(--card))',
					foreground: 'hsl(var(--card-foreground))'
				},
				sidebar: {
					DEFAULT: 'hsl(var(--sidebar-background))',
					foreground: 'hsl(var(--sidebar-foreground))',
					primary: 'hsl(var(--sidebar-primary))',
					'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
					accent: 'hsl(var(--sidebar-accent))',
					'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
					border: 'hsl(var(--sidebar-border))',
					ring: 'hsl(var(--sidebar-ring))'
				},
				// Custom colors for our irrigation app
				irrigation: {
					green: '#4CAF50',
					blue: '#2196F3',
					earth: '#8D6E63',
					lightGreen: '#81C784',
					lightBlue: '#64B5F6',
					dark: '#263238',
					gray: '#ECEFF1'
				}
			},
			borderRadius: {
				lg: 'var(--radius)',
				md: 'calc(var(--radius) - 2px)',
				sm: 'calc(var(--radius) - 4px)'
			},
			keyframes: {
				'accordion-down': {
					from: {
						height: '0'
					},
					to: {
						height: 'var(--radix-accordion-content-height)'
					}
				},
				'accordion-up': {
					from: {
						height: 'var(--radix-accordion-content-height)'
					},
					to: {
						height: '0'
					}
				}
			},
			animation: {
				'accordion-down': 'accordion-down 0.2s ease-out',
				'accordion-up': 'accordion-up 0.2s ease-out'
			}
		}
	},
	plugins: [require("tailwindcss-animate")],
} satisfies Config;


====================================================================
==== FILE: tsconfig.json ====
====================================================================

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}


====================================================================
==== FILE: src/main.tsx ====
====================================================================

import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById("root")!).render(<App />);


====================================================================
==== FILE: src/index.css ====
====================================================================


@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;

    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;

    --primary: 122 39% 49%;
    --primary-foreground: 210 40% 98%;

    --secondary: 210 79% 54%;
    --secondary-foreground: 222.2 47.4% 11.2%;

    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;

    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 122 39% 49%;

    --radius: 0.5rem;

    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 122 39% 49%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 122 39% 49%;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;

    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;

    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;

    --primary: 122 39% 49%;
    --primary-foreground: 222.2 47.4% 11.2%;

    --secondary: 210 79% 54%;
    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 122 39% 49%;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
  }
}

/* Custom styles for the irrigation app */
.soil-moisture-chart {
  height: 200px;
  width: 100%;
}

.weather-icon {
  font-size: 2.5rem;
}

.irrigation-recommendation {
  border-left: 4px solid theme('colors.irrigation.green');
}


====================================================================
==== FILE: src/App.tsx ====
====================================================================

import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import Index from "./pages/Index";
import Sensors from "./pages/Sensors";
import Weather from "./pages/Weather";
import Crops from "./pages/Crops";
import Settings from "./pages/Settings";
import NotFound from "./pages/NotFound";
// The Outlet component is not needed here because you are defining all routes explicitly.

const queryClient = new QueryClient();

// This is your main App component that controls the entire application structure.
const App = () => (
  <QueryClientProvider client={queryClient}>
    <TooltipProvider>
      {/* This is the standard Toaster. It's fine to leave it. */}
      <Toaster />

      {/* --- THIS IS THE LINE TO MODIFY --- */}
      {/* Add the props to your existing Sonner component. */}
      <Sonner position="top-center" richColors />

      <BrowserRouter>
        <Routes>
          <Route path="/" element={<Index />} />
          <Route path="/sensors" element={<Sensors />} />
          <Route path="/weather" element={<Weather />} />
          <Route path="/crops" element={<Crops />} />
          <Route path="/settings" element={<Settings />} />
          <Route path="*" element={<NotFound />} />
        </Routes>
      </BrowserRouter>
    </TooltipProvider>
  </QueryClientProvider>
);

// We no longer need the second, conflicting App function definition.
// function App() { ... } <-- DELETE THIS

export default App;

====================================================================
==== FILE: src/pages/Crops.tsx ====
====================================================================

// src/pages/Crops.tsx

import React, { useState, useEffect, useMemo } from "react"; // Added useMemo
import Navbar from "@/components/navigation/Navbar";
import Sidebar from "@/components/navigation/Sidebar";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Droplet, Calendar, CircleChevronUp, CircleChevronDown, Sprout, LoaderCircle, AlertTriangle, Sparkles } from "lucide-react";
import { AddNewCropDialog } from "@/components/crops/AddNewCropDialog";
import { IrrigationCalendar } from "@/components/crops/IrrigationCalendar";

// --- TypeScript Type Definitions ---
type AISchedule = {
  schedule: number[];
  quantity: number[];
};

type CropType = {
  _id: string;
  name: string;
  stage: 'Seedling' | 'Growing' | 'Mature' | 'Harvesting';
  waterNeeds: 'Low' | 'Medium' | 'Medium-High' | 'High';
  plantedDate: string;
  nextWatering: string;
  aiSchedule?: AISchedule;
};

// ===================================================================
// The Enhanced CropCard Component
// ===================================================================
const CropCard = ({ crop }: { crop: CropType }) => {
  const [isExpanded, setIsExpanded] = React.useState(false);

  // --- State Management for AI Feature ---
  const [originalSchedule, setOriginalSchedule] = useState<AISchedule | null>(crop.aiSchedule || null);
  const [isLoadingSchedule, setIsLoadingSchedule] = useState<boolean>(false);
  const [scheduleError, setScheduleError] = useState<string | null>(null);

  // ===================================================================
  // --- NEW: FUNCTION TO APPLY ZERO-IRRIGATION DAYS (FRONTEND ONLY) ---
  // ===================================================================
  const applyZeroIrrigationDays = (
    scheduleData: AISchedule | null, 
    waterNeeds: CropType['waterNeeds']
  ): AISchedule | null => {
    if (!scheduleData) return null;

    // Clone the original data to avoid modifying the state directly
    const newSchedule = [...scheduleData.schedule];
    const newQuantity = [...scheduleData.quantity];

    // 1. Define how many zero-days we want per week for each level
    const zeroDaysTargetPerWeek = {
      'Low': 5,
      'Medium': 4,
      'Medium-High': 3,
      'High': 2
    };

    // Calculate total zero-days needed for the 14-day period
    const totalZeroDaysNeeded = zeroDaysTargetPerWeek[waterNeeds] * 2;

    // 2. Find all days that currently have watering scheduled
    const wateringDays = newSchedule
      .map((s, index) => (s === 1 ? { index, quantity: newQuantity[index] } : null))
      .filter(Boolean);
      
    // If we already have enough or more zero days than needed, do nothing.
    const currentZeroDays = 14 - wateringDays.length;
    if (currentZeroDays >= totalZeroDaysNeeded) {
        return scheduleData;
    }

    // 3. Sort the watering days by the SMALLEST quantity first
    wateringDays.sort((a, b) => a!.quantity - b!.quantity);

    // 4. Calculate how many days we need to "turn off"
    const daysToZeroOut = wateringDays.length - (14 - totalZeroDaysNeeded);
    
    // 5. Take the smallest ones and set them to 0
    if (daysToZeroOut > 0) {
      const daysToChange = wateringDays.slice(0, daysToZeroOut);
      for (const day of daysToChange) {
        newSchedule[day!.index] = 0;
        newQuantity[day!.index] = 0;
      }
    }

    return { schedule: newSchedule, quantity: newQuantity };
  };

  // --- Use useMemo to prevent re-calculating on every render ---
  // This derived state will be used for display.
  const displaySchedule = useMemo(
    () => applyZeroIrrigationDays(originalSchedule, crop.waterNeeds),
    [originalSchedule, crop.waterNeeds]
  );
  // ===================================================================
  // --- END OF NEW LOGIC ---
  // ===================================================================


  const handleGenerateSchedule = async () => {
    setIsLoadingSchedule(true);
    setScheduleError(null);
    try {
      const response = await fetch(`/api/ai/schedule/${crop._id}`, { method: 'POST' });
      const data = await response.json();
      if (!response.ok || !data.success) {
        throw new Error(data.message || "Failed to generate schedule.");
      }
      // Set the RAW, unmodified schedule from the backend
      setOriginalSchedule(data.data); 
    } catch (err: any) {
      setScheduleError(err.message);
    } finally {
      setIsLoadingSchedule(false);
    }
  };

  const formatDate = (dateString: string) => new Date(dateString).toLocaleDateString("en-US", { year: 'numeric', month: 'long', day: 'numeric' });
  
  const getWaterNeedsColor = (needs: string) => {
    // ... (this function remains the same)
    switch(needs) {
      case "Low": return "bg-green-100 text-green-800";
      case "Medium": return "bg-blue-100 text-blue-800";
      case "Medium-High": return "bg-indigo-100 text-indigo-800";
      case "High": return "bg-purple-100 text-purple-800";
      default: return "bg-gray-100 text-gray-800";
    }
  };
  const getStageColor = (stage: string) => {
    // ... (this function remains the same)
    switch(stage) {
      case "Seedling": return "bg-green-100 text-green-800";
      case "Growing": return "bg-blue-100 text-blue-800";
      case "Mature": return "bg-amber-100 text-amber-800";
      case "Harvesting": return "bg-purple-100 text-purple-800";
      default: return "bg-gray-100 text-gray-800";
    }
  };

  return (
    <Card className="overflow-hidden shadow-md transition-all duration-300">
      <div className="p-4 flex items-center justify-between cursor-pointer" onClick={() => setIsExpanded(!isExpanded)}>
        {/* ... (this part of the component remains the same) ... */}
         <div className="flex items-center">
          <div className="mr-4 w-12 h-12 rounded-full bg-irrigation-green flex items-center justify-center text-white text-xl font-bold">
            {crop.name.charAt(0)}
          </div>
          <div>
            <h3 className="font-semibold text-lg">{crop.name}</h3>
            <div className="flex gap-2 mt-1">
              <span className={`text-xs px-2 py-1 rounded-full ${getStageColor(crop.stage)}`}>{crop.stage}</span>
              <span className={`text-xs px-2 py-1 rounded-full ${getWaterNeedsColor(crop.waterNeeds)}`}>{crop.waterNeeds} Water</span>
            </div>
          </div>
        </div>
        {isExpanded ? <CircleChevronUp className="text-gray-500" /> : <CircleChevronDown className="text-gray-400" />}
      </div>
      
      {isExpanded && (
        <CardContent className="border-t pt-4 space-y-6">
          <div>
              <h4 className="text-sm font-medium text-gray-800 mb-3">Crop Details</h4>
              <div className="grid grid-cols-1 sm:grid-cols-3 gap-4 text-sm">
                  <div className="flex items-center gap-2 p-2 bg-gray-50 rounded-lg">
                      <Sprout className="h-5 w-5 text-green-600 flex-shrink-0" />
                      <div>
                          <p className="text-gray-500">Planted On</p>
                          <p className="font-semibold">{formatDate(crop.plantedDate)}</p>
                      </div>
                  </div>
                  <div className="flex items-center gap-2 p-2 bg-gray-50 rounded-lg">
                      <Calendar className="h-5 w-5 text-gray-600 flex-shrink-0" />
                      <div>
                          <p className="text-gray-500">Next Manual Watering</p>
                          <p className="font-semibold">{formatDate(crop.nextWatering)}</p>
                      </div>
                  </div>
                  <div className="flex items-center gap-2 p-2 bg-gray-50 rounded-lg">
                      <Droplet className="h-5 w-5 text-blue-600 flex-shrink-0" />
                      <div>
                          <p className="text-gray-500">Water Needs</p>
                          <p className="font-semibold">{crop.waterNeeds}</p>
                      </div>
                  </div>
              </div>
          </div>
          
          {/* --- AI Schedule Section --- */}
          <div className="p-4 bg-gray-50 rounded-lg border">
            {/* --- MODIFIED: Use the `displaySchedule` for rendering --- */}
            {displaySchedule ? (
              <IrrigationCalendar schedule={displaySchedule.schedule} quantity={displaySchedule.quantity} />
            ) : (
              <div className="text-center py-4">
                <h3 className="font-semibold text-gray-700">Generate AI Forecast</h3>
                <p className="text-sm text-gray-500 my-2">Use the Vision Transformer model to predict the optimal 14-day irrigation plan.</p>
                <Button onClick={handleGenerateSchedule} disabled={isLoadingSchedule}>
                  {isLoadingSchedule ? (<><LoaderCircle className="mr-2 h-4 w-4 animate-spin" />Generating...</>) : (<><Sparkles className="mr-2 h-4 w-4" />Generate Schedule</>)}
                </Button>
              </div>
            )}
            {scheduleError && <p className="text-red-500 text-sm mt-2 text-center">Error: {scheduleError}</p>}
          </div>
          {displaySchedule && !isLoadingSchedule && (
            <div className="text-center -mt-4">
                <Button variant="link" size="sm" onClick={handleGenerateSchedule}>Re-generate Schedule</Button>
            </div>
          )}
        </CardContent>
      )}
    </Card>
  );
};

// ===================================================================
// The Main Crops Page Component (No changes needed here)
// ===================================================================
const Crops = () => {
    // ... (The entire `Crops` component remains exactly the same) ...
    const [crops, setCrops] = useState<CropType[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetchCrops = async () => {
        try {
            const response = await fetch("/api/crops");
            const data = await response.json();
            if (data.success) {
            setCrops(data.data);
            } else {
            throw new Error(data.message || "Failed to fetch crops.");
            }
        } catch (err: any) {
            setError(err.message);
        } finally {
            setLoading(false);
        }
        };
        fetchCrops();
    }, []);

    const handleCropAdded = (newCrop: CropType) => {
        setCrops((prevCrops) => [newCrop, ...prevCrops]);
    };

    const renderContent = () => {
        if (loading) return <div className="flex justify-center p-8"><LoaderCircle className="animate-spin h-8 w-8 text-irrigation-green" /></div>;
        if (error) return <div className="p-4 bg-red-50 text-red-600 rounded-md"><AlertTriangle className="inline mr-2" />Error: {error}</div>;
        if (crops.length === 0) return <div className="text-center p-8 bg-gray-100 rounded-lg"><p>No crops found. Add one to get started!</p></div>;
        return (
        <div className="space-y-6">
            {crops.map((crop) => <CropCard key={crop._id} crop={crop} />)}
        </div>
        );
    };

    return (
        <div className="min-h-screen flex flex-col bg-gray-50">
        <Navbar />
        <div className="flex flex-1 overflow-hidden">
            <aside className="w-64 hidden md:block"><Sidebar /></aside>
            <main className="flex-1 overflow-y-auto p-6">
            <div className="max-w-7xl mx-auto">
                <div className="flex items-center justify-between mb-6">
                <div>
                    <h1 className="text-3xl font-bold text-gray-800">Crops</h1>
                    <p className="text-gray-600">Manage your crops and view AI-powered irrigation forecasts.</p>
                </div>
                <AddNewCropDialog onCropAdded={handleCropAdded} />
                </div>
                {renderContent()}
            </div>
            </main>
        </div>
        </div>
    );
};

export default Crops;

====================================================================
==== FILE: src/pages/Index.tsx ====
====================================================================


import React from "react";
import Navbar from "@/components/navigation/Navbar";
import Sidebar from "@/components/navigation/Sidebar";
import SoilMoistureChart from "@/components/dashboard/SoilMoistureChart";
import WeatherForecast from "@/components/dashboard/WeatherForecast";
import IrrigationRecommendations from "@/components/dashboard/IrrigationRecommendations";

const Index = () => {
  return (
    <div className="min-h-screen flex flex-col bg-gray-50">
      <Navbar />
      <div className="flex flex-1 overflow-hidden">
        <aside className="w-64 hidden md:block">
          <Sidebar />
        </aside>
        <main className="flex-1 overflow-y-auto p-6">
          <div className="max-w-7xl mx-auto">
            <div className="mb-6">
              <h1 className="text-3xl font-bold text-gray-800">Dashboard</h1>
              <p className="text-gray-600">Overview of your irrigation system</p>
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <SoilMoistureChart />
              <WeatherForecast />
            </div>
            
            <div className="mt-6">
              <IrrigationRecommendations />
            </div>
          </div>
        </main>
      </div>
    </div>
  );
};

export default Index;


====================================================================
==== FILE: src/pages/Weather.tsx.tsx (NOT FOUND) ====
====================================================================


====================================================================
==== FILE: src/components/dashboard/IrrigationRecommendations.tsx ====
====================================================================

import React, { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Droplet, LoaderCircle, AlertTriangle, Info } from "lucide-react";

// --- TypeScript Type for a single recommendation ---
type RecommendationType = {
  _id: string;
  cropId: {
    name: string;
  };
  recommendation: {
    action: string;
    priority: string;
  };
};

const IrrigationRecommendations: React.FC = () => {
  // --- STATE MANAGEMENT ---
  const [recommendations, setRecommendations] = useState<RecommendationType[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // --- DATA FETCHING ---
  useEffect(() => {
    const fetchRecommendations = async () => {
      try {
        const response = await fetch("/api/irrigation/recommendations/pending");
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.json();
        if (data.success) {
          setRecommendations(data.data);
        } else {
          throw new Error(data.message || "Failed to fetch recommendations.");
        }
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchRecommendations();
  }, []);

  // --- RENDERING LOGIC ---
  const renderPriorityColor = (priority: string) => {
    switch (priority.toLowerCase()) {
      case 'critical': return 'bg-red-500';
      case 'high': return 'bg-orange-500';
      case 'medium': return 'bg-yellow-400';
      default: return 'bg-irrigation-green';
    }
  };

  const renderContent = () => {
    if (loading) {
      return <div className="flex items-center justify-center p-4"><LoaderCircle className="animate-spin h-6 w-6 text-irrigation-green" /></div>;
    }
    if (error) {
      return <div className="flex items-center text-red-600 p-4"><AlertTriangle className="h-5 w-5 mr-2" /> Error: {error}</div>;
    }
    if (recommendations.length === 0) {
      return (
        <div className="flex items-center text-gray-500 p-4">
          <Info className="h-5 w-5 mr-2" /> All irrigation schedules are up to date.
        </div>
      );
    }
    return (
      <div className="space-y-3">
        {recommendations.map((rec) => (
          <div 
            key={rec._id} 
            className="flex justify-between items-center p-3 rounded-md bg-white border border-gray-100"
          >
            <div className="flex items-center gap-3">
              <div className={`w-2 h-6 rounded-full ${renderPriorityColor(rec.recommendation.priority)}`}></div>
              <span>{rec.cropId.name}</span>
            </div>
            <div className="flex items-center">
              {!rec.recommendation.action.includes('No') && (
                <Droplet className={`h-4 w-4 mr-1 ${rec.recommendation.priority === 'Critical' ? 'text-irrigation-blue' : 'text-gray-400'}`} />
              )}
              <span className="text-sm">{rec.recommendation.action}</span>
            </div>
          </div>
        ))}
      </div>
    );
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-lg font-medium">Irrigation Recommendations</CardTitle>
      </CardHeader>
      <CardContent>
        {renderContent()}
      </CardContent>
    </Card>
  );
};

export default IrrigationRecommendations;

====================================================================
==== FILE: src/components/dashboard/SoilMoistureChart.tsx ====
====================================================================

import React, { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { LoaderCircle, AlertTriangle } from "lucide-react";

// --- TypeScript Type for a sensor reading ---
type Reading = {
  timestamp: string;
  readings: {
    soilMoisture: number;
  };
};

// --- TODO: Replace this with an actual sensor ID from your database ---
const SENSOR_ID_FOR_DASHBOARD = "684303b406e7606c83a1330f"; // PASTE THE ID YOU COPIED HERE

const SoilMoistureChart: React.FC = () => {
  // --- STATE MANAGEMENT ---
  const [data, setData] = useState<any[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // --- DATA FETCHING ---
  useEffect(() => {
    if (SENSOR_ID_FOR_DASHBOARD === "YOUR_SENSOR_ID_HERE") {
        setError("Please update the SENSOR_ID_FOR_DASHBOARD in the code.");
        setLoading(false);
        return;
    }

    const fetchMoistureData = async () => {
      try {
        // Fetch the last 24 readings (assuming 1 per hour for a day)
        const response = await fetch(`/api/sensors/${SENSOR_ID_FOR_DASHBOARD}/readings?limit=24&sort=asc`);
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const result = await response.json();
        if (result.success) {
          // Format data for the chart
          const formattedData = result.data.map((reading: Reading) => ({
            // Format timestamp to just show the time (e.g., "14:00")
            time: new Date(reading.timestamp).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }),
            moisture: reading.readings.soilMoisture,
          }));
          setData(formattedData);
        } else {
          throw new Error(result.message || "Failed to fetch sensor data.");
        }
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchMoistureData();
  }, []);

  const renderChart = () => {
    if (loading) {
      return <div className="flex items-center justify-center h-48"><LoaderCircle className="animate-spin h-6 w-6 text-irrigation-green" /></div>;
    }
    if (error) {
      return <div className="flex items-center text-red-600 p-4 h-48"><AlertTriangle className="h-5 w-5 mr-2" /> {error}</div>;
    }
    if (data.length === 0) {
      return <div className="flex items-center justify-center text-gray-500 h-48">No moisture data available for this sensor.</div>;
    }
    return (
      <ResponsiveContainer width="100%" height={200}>
        <LineChart data={data}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="time" fontSize={12} tickLine={false} axisLine={false} />
          <YAxis fontSize={12} tickLine={false} axisLine={false} unit="%" />
          <Tooltip 
            contentStyle={{ backgroundColor: 'white', border: '1px solid #ccc' }} 
            labelStyle={{ fontWeight: 'bold' }}
            formatter={(value) => [`${value}%`, 'Moisture']}
          />
          <Line 
            type="monotone" 
            dataKey="moisture" 
            stroke="#3b82f6" // Using a blue color
            strokeWidth={2}
            dot={{ r: 4, fill: '#3b82f6' }}
            activeDot={{ r: 6, stroke: '#1d4ed8' }}
          />
        </LineChart>
      </ResponsiveContainer>
    );
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-lg font-medium">Soil Moisture (%)</CardTitle>
      </CardHeader>
      <CardContent>
        {renderChart()}
      </CardContent>
    </Card>
  );
};

export default SoilMoistureChart;

====================================================================
==== FILE: src/components/dashboard/WeatherForecast.tsx ====
====================================================================

import React, { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { LoaderCircle, AlertTriangle } from "lucide-react";

// Helper function to get a dynamic OpenWeatherMap icon URL
const getWeatherIconUrl = (iconCode: string) => `https://openweathermap.org/img/wn/${iconCode}@2x.png`;

// Updated TypeScript type definitions to match our new API response from the backend
type WeatherData = {
  current: {
    temperature: number;
    condition_desc: string;
    icon: string;
  };
  daily: {
    timestamp: string;
    temperature: { min: number; max: number };
    icon: string;
  }[];
};

const WeatherForecast: React.FC = () => {
  const [weather, setWeather] = useState<WeatherData | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchWeather = async () => {
      try {
        // Fetch from the new, correct endpoint for the dashboard
        const response = await fetch("/api/weather/bangalore");
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.message || `HTTP error! Status: ${response.status}`);
        }
        
        const data = await response.json();
        if (data.success) {
          setWeather(data.data);
        } else {
          throw new Error(data.message || "Failed to fetch weather data.");
        }
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchWeather();
  }, []);

  // Helper function to get the short day of the week (e.g., "Mon") from a date string
  const getDayOfWeek = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', { weekday: 'short' });
  };
  
  const renderContent = () => {
    if (loading) {
      return <div className="flex items-center justify-center p-4 h-40"><LoaderCircle className="animate-spin h-6 w-6 text-irrigation-blue" /></div>;
    }
    
    if (error || !weather) {
      return <div className="flex items-center text-red-600 p-4 h-40"><AlertTriangle className="h-5 w-5 mr-2" /> {error || "Weather data could not be loaded."}</div>;
    }

    return (
      <div className="text-center">
        <div className="flex items-center justify-center mb-4">
          <img src={getWeatherIconUrl(weather.current.icon)} alt={weather.current.condition_desc} className="w-16 h-16 -my-2" />
          <div>
            <div className="text-4xl font-bold">{Math.round(weather.current.temperature)}°C</div>
            <div className="text-sm text-gray-500 capitalize">{weather.current.condition_desc}</div>
          </div>
        </div>
        
        <div className="flex justify-between mt-6">
          {weather.daily.slice(0, 5).map((day, index) => (
            <div key={index} className="text-center">
              <div className="font-medium">{getDayOfWeek(day.timestamp)}</div>
              <div className="my-2">
                <img src={getWeatherIconUrl(day.icon)} alt="weather icon" className="w-10 h-10 mx-auto" />
              </div>
              <div className="text-xs">{Math.round(day.temperature.max)}°/{Math.round(day.temperature.min)}°</div>
            </div>
          ))}
        </div>
      </div>
    );
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-lg font-medium">Weather Forecast</CardTitle>
      </CardHeader>
      <CardContent>
        {renderContent()}
      </CardContent>
    </Card>
  );
};

export default WeatherForecast;

====================================================================
==== FILE: src/lib/utils.ts ====
====================================================================

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


